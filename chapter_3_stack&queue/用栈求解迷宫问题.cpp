#include<iostream>
using namespace std;
/*迷宫如下*/
#define M 8
#define N 8
#define Maxsize 100
int mg[M+2][N+2]={{1,1,1,1,1,1,1,1,1,1},{1,0,0,1,0,0,0,1,0,1},
				  {1,0,0,1,0,0,0,1,0,1},{1,0,0,0,0,1,1,0,0,1}
				  {1,0,1,1,1,0,0,0,0,1},{1,0,0,0,1,0,0,0,0,1}
				  {1,0,1,0,0,0,1,0,0,1},{1,0,1,1,1,0,1,1,0,1}
				  {1,1,0,0,0,0,0,0,0,1},{1,1,1,1,1,1,1,1,1,1}};
/*迷宫栈元素*/
typedef struct{
	int i;   //方块行号
	int j;   //方块列号
	int di;  //di表示下一个可走的方位号
}Box;

/*迷宫栈*/
typedef struct{
	Box data[Maxsize];
	int top;
}
/*求解迷宫问题的伪代码描述：
bool mgpath(入口xi，yi；出口xe，ye)
{
	首先将入口Box进栈，初始下一跳方位为-1；
	把入口的迷宫值设置为-1，避免重复走到该方块。
	取栈顶方块（i，j，di）
	if(i,j是出口xe，ye)
	{
		正向输出全部栈中元素，构成完整路径
		return true;
	}
	查找下一个相邻，可走，的方块；
	if(有可走方块)
	{
		在当栈顶块记下对应方位di；
		将该下一个可走方块进栈；
		把当前Box标记为-1，避免死循环；
	}
	if(没有可走方块)
	{
		出栈当前方块；
		把当前栈顶方块的迷宫值重新设置为0；
	}
}
如果最后栈空，则说明入口Box最终退栈，则迷宫无解，return false。
*/

int main(){
	
	return 0;
}